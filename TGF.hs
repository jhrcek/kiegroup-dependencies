{-# LANGUAGE OverloadedStrings #-}
module TGF (parse, toTree) where

import Data.Attoparsec.Text (Parser, char, decimal, endOfInput, endOfLine, isEndOfLine, parseOnly, sepBy, skipMany, space, takeTill)
import Data.Maybe (mapMaybe)
import Data.Text (Text)
import Data.Tree

-- Generic TGF parsing
type NodeId = Int
type NodeData = (NodeId, Text)
type EdgeData = (NodeId, NodeId, Text)


data TGF = TGF
  { nodeDeclarations :: [NodeData]
  , edgeDeclarations :: [EdgeData]
  } deriving Show


parse :: Text -> Either String TGF
parse = parseOnly tgfP


tgfP :: Parser TGF
tgfP = TGF
    <$> (nodeDeclP `sepBy` endOfLine) <* (endOfLine >> char '#' >> endOfLine)
    <*> (edgeDeclP `sepBy` endOfLine) <* (skipMany space >> endOfInput)


nodeDeclP :: Parser NodeData
nodeDeclP = (,)
    <$> (decimal <* space)
    <*> (takeTill isEndOfLine)


edgeDeclP :: Parser EdgeData
edgeDeclP = (,,)
    <$> (decimal <* space)
    <*> (decimal <* space)
    <*> (takeTill isEndOfLine)

-- Stuff specific to TGF files generated by mvn dependency:analyze -DoutputType=tfg
-- Assuming those files are always valid trees
toTree :: TGF -> Tree NodeId
toTree tgf =
  -- Assuming root of the tree is the first node declared
  let rootId = fst . head $ nodeDeclarations tgf
  in buildTree rootId $ edgeDeclarations tgf


buildTree :: NodeId -> [EdgeData] -> Tree NodeId
buildTree rootId edges =
  let childrenOfRoot = mapMaybe (\(fromNodeId, toNodeId, _edgeText) -> if rootId == fromNodeId then Just toNodeId else Nothing) edges
  in Node rootId . fmap (\child -> buildTree child edges) $ childrenOfRoot
