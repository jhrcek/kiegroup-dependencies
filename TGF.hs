{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TupleSections     #-}
module TGF
  ( parseDeps
  , Tree
  , NodeId
  , Dependency
  , depNames
  , depTree
  , Deps
  , dGroupId
  , dArtifactId
  , dPackaging
  , dVersion
  , dScope
  , equalByGroupAndArtifact
  ) where


import Data.Attoparsec.Text (Parser, char, decimal, endOfInput, endOfLine, isEndOfLine, parseOnly, sepBy, skipMany, space, takeTill)
import Data.Char (isDigit)
import Data.IntMap.Strict (IntMap)
import qualified Data.IntMap.Strict as IntMap
import Data.Maybe (mapMaybe)
import Data.Text (Text, splitOn, unpack)
import Data.Tree


-- Generic TGF parsing

type NodeId = Int
type NodeData = (NodeId, Text)
type EdgeData = (NodeId, NodeId, Text)


data TGF = TGF
  { nodeDeclarations :: [NodeData]
  , edgeDeclarations :: [EdgeData]
  } deriving Show


parseTGF :: Text -> Either String TGF
parseTGF = parseOnly tgfP


tgfP :: Parser TGF
tgfP = TGF
    <$> (nodeDeclP `sepBy` endOfLine) <* (endOfLine >> char '#' >> endOfLine)
    <*> (edgeDeclP `sepBy` endOfLine) <* (skipMany space >> endOfInput)


nodeDeclP :: Parser NodeData
nodeDeclP = (,)
    <$> (decimal <* space)
    <*> (takeTill isEndOfLine)


edgeDeclP :: Parser EdgeData
edgeDeclP = (,,)
    <$> (decimal <* space)
    <*> (decimal <* space)
    <*> (takeTill isEndOfLine)


-- Stuff specific to TGF files generated by mvn dependency:analyze -DoutputType=tfg
-- Assuming those files always contain valid trees


{-| Represents all data from a single .tgf file produced by mvn dependency:analyze -DoutputType=tfg-}
data Deps = Deps
    { depNames :: IntMap Dependency
    , depTree  :: Tree NodeId
    } deriving Show

parseDeps :: Text -> Either String Deps
parseDeps tgfSource = parseTGF tgfSource >>= toDeps

toDeps :: TGF -> Either String Deps
toDeps tgf =
  let eitherErrorOrListOfDeps = mapM (\(nid, depText) -> (nid,) <$> readDependency depText) $ nodeDeclarations tgf
  in case eitherErrorOrListOfDeps of
        Right listOfDeps ->  Right $ Deps {depNames = IntMap.fromList listOfDeps, depTree = toTree tgf}
        Left err         -> Left err


{-| Represents data contained in " org.apache.xmlbeans:xmlbeans:jar:2.6.0:compile" -}
data Dependency = Dependency
    { dGroupId    :: Text
    , dArtifactId :: Text
    , dPackaging  :: Text
    , dVersion    :: Text
    , dScope      :: Text
    } deriving (Eq, Ord, Show)

equalByGroupAndArtifact :: Dependency -> Dependency -> Bool
equalByGroupAndArtifact d1 d2 =
    dGroupId d1 == dGroupId d2 && dArtifactId d1 == dArtifactId d2


readDependency :: Text -> Either String Dependency
readDependency txt =
    let dep = case splitOn ":" txt of
              [group,artifact,packaging,_qualifier,version,scope] -> Right $ Dependency group artifact packaging version scope
              [group,artifact,packaging,version,scope]            -> Right $ Dependency group artifact packaging version scope
              [group,artifact,packaging,version]                  -> Right $ Dependency group artifact packaging version "compile"
              _                                                   -> Left $ "Unexpected dependency format: " ++ unpack txt
        validateVersion d = if any isDigit (unpack (dVersion d)) || dVersion d == "jdk"
                                   then return d
                                   else Left $ "I was expecting verision to contain at least one digit in " ++ show d
        validatePackaging d = if any (== (dPackaging d)) knownPackagings
                               then return d
                               else Left $ "Urecognized dependency packaging in " ++ show d
        validateScope d = if any (== (dScope d)) knownScopes
                           then return d
                           else Left $ "Unrecognized scope in " ++ show d
    in dep >>= validateVersion >>= validatePackaging >>= validateScope


knownPackagings :: [Text]
knownPackagings =
    ["bundle"
    ,"eclipse-feature"
    ,"eclipse-plugin"
    ,"eclipse-repository"
    ,"eclipse-test-plugin"
    ,"gwt-lib"
    ,"jar"
    ,"kjar"
    ,"maven-archetype"
    ,"maven-module"
    ,"maven-plugin"
    ,"pom"
    ,"takari-maven-plugin"
    ,"tar.gz"
    ,"test-jar"
    ,"war"
    ,"xml"
    ,"zip"
    ]

knownScopes :: [Text]
knownScopes =
    ["compile"
    ,"compile (optional) "
    ,"provided"
    ,"provided (optional) "
    ,"runtime"
    ,"runtime (optional) "
    ,"system"
    ,"test"
    ,"test (optional) "
    ]


toTree :: TGF -> Tree NodeId
toTree tgf =
  -- Assuming root of the tree is the first node declared
  let rootId = fst . head $ nodeDeclarations tgf
  in buildTree rootId $ edgeDeclarations tgf


buildTree :: NodeId -> [EdgeData] -> Tree NodeId
buildTree rootId edges =
  let childrenOfRoot = mapMaybe (\(fromNodeId, toNodeId, _edgeText) -> if rootId == fromNodeId then Just toNodeId else Nothing) edges
  in Node rootId . fmap (\child -> buildTree child edges) $ childrenOfRoot
