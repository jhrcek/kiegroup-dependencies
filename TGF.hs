{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TupleSections     #-}
module TGF
  ( parseDeps
  , Tree
  , NodeId
  , Dependency
  , depNames
  , depTree
  , Deps
  , dGroupId
  , dArtifactId
  , dPackaging
  , dQualifier
  , dVersion
  , dScope
  , equalByGroupAndArtifact
  ) where


import Data.Attoparsec.Text (Parser, char, decimal, endOfInput, endOfLine, isEndOfLine, parseOnly, sepBy, skipMany, space, takeTill)
import Data.Char (isDigit)
import Data.IntMap.Strict (IntMap)
import qualified Data.IntMap.Strict as IntMap
import Data.Maybe (mapMaybe)
import Data.Text (Text)
import qualified Data.Text as Txt
import Data.Tree

-- Generic TGF parsing

type NodeId = Int
type NodeData = (NodeId, Text)
type EdgeData = (NodeId, NodeId, Text)


data TGF = TGF
  { nodeDeclarations :: [NodeData]
  , edgeDeclarations :: [EdgeData]
  } deriving Show


parseTGF :: Text -> Either String TGF
parseTGF = parseOnly tgfP


tgfP :: Parser TGF
tgfP = TGF
    <$> (nodeDeclP `sepBy` endOfLine) <* (endOfLine >> char '#' >> endOfLine)
    <*> (edgeDeclP `sepBy` endOfLine) <* (skipMany space >> endOfInput)


nodeDeclP :: Parser NodeData
nodeDeclP = (,)
    <$> decimal <* space
    <*> takeTill isEndOfLine


edgeDeclP :: Parser EdgeData
edgeDeclP = (,,)
    <$> decimal <* space
    <*> decimal <* space
    <*> takeTill isEndOfLine


-- Stuff specific to TGF files generated by mvn dependency:analyze -DoutputType=tfg
-- Assuming those files always contain valid trees


{-| Represents all data from a single .tgf file produced by mvn dependency:analyze -DoutputType=tfg-}
data Deps = Deps
    { depNames :: IntMap Dependency
    , depTree  :: Tree NodeId
    } deriving Show


parseDeps :: Text -> Either String Deps
parseDeps tgfSource = parseTGF tgfSource >>= toDeps


toDeps :: TGF -> Either String Deps
toDeps tgf =
  let eitherErrorOrListOfDeps = mapM (\(nid, depText) -> (nid,) <$> readDependency depText) $ nodeDeclarations tgf
  in case eitherErrorOrListOfDeps of
        Right listOfDeps -> Right Deps{depNames = IntMap.fromList listOfDeps, depTree = toTree tgf}
        Left err         -> Left err


{-| Represents data contained in " org.apache.xmlbeans:xmlbeans:jar:2.6.0:compile" -}
data Dependency = Dependency
    { dGroupId    :: Text
    , dArtifactId :: Text
    , dPackaging  :: Text
    , dQualifier  :: Maybe Text
    , dVersion    :: Text
    , dScope      :: Text
    } deriving (Eq, Ord)


instance Show Dependency where
    show (Dependency grp art pac mayQualifier ver sco) =
        Txt.unpack $ Txt.intercalate ":" fields
      where
        fields = case mayQualifier of
            Just qual -> [grp, art, pac, qual, ver, sco]
            Nothing   -> [grp, art, pac,       ver, sco]


equalByGroupAndArtifact :: Dependency -> Dependency -> Bool
equalByGroupAndArtifact d1 d2 =
    dGroupId d1 == dGroupId d2 && dArtifactId d1 == dArtifactId d2


readDependency :: Text -> Either String Dependency
readDependency txt =
    let dep = case Txt.splitOn ":" txt of
              [group,artifact,packaging,qualifier,version,scope] -> Right $ Dependency group artifact packaging (Just qualifier) version scope
              [group,artifact,packaging,version,scope]           -> Right $ Dependency group artifact packaging Nothing version scope
              [group,artifact,packaging,version]                 -> Right $ Dependency group artifact packaging Nothing version "compile"
              _                                                  -> Left $ "Unexpected dependency format: " ++ Txt.unpack txt
        validateVersion d = if any isDigit (Txt.unpack (dVersion d)) || dVersion d == "jdk"
                                   then return d
                                   else Left $ "I was expecting verision to contain at least one digit in " ++ show d
        validatePackaging d = if dPackaging d `elem` knownPackagings
                               then return d
                               else Left $ "Urecognized dependency packaging in " ++ show d
        validateScope d = if dScope d `elem` knownScopes
                           then return d
                           else Left $ "Unrecognized scope in " ++ show d
    in dep >>= validateVersion >>= validatePackaging >>= validateScope


knownPackagings :: [Text]
knownPackagings =
    ["bundle"
    ,"eclipse-feature"
    ,"eclipse-plugin"
    ,"eclipse-repository"
    ,"eclipse-test-plugin"
    ,"gwt-lib"
    ,"jar"
    ,"kjar"
    ,"maven-archetype"
    ,"maven-module"
    ,"maven-plugin"
    ,"pom"
    ,"takari-maven-plugin"
    ,"tar.gz"
    ,"test-jar"
    ,"war"
    ,"xml"
    ,"zip"
    ]


knownScopes :: [Text]
knownScopes =
    ["compile"
    ,"compile (optional) "
    ,"provided"
    ,"provided (optional) "
    ,"runtime"
    ,"runtime (optional) "
    ,"system"
    ,"test"
    ,"test (optional) "
    ]


toTree :: TGF -> Tree NodeId
toTree tgf =
  -- Assuming root of the tree is the first node declared
  let rootId = fst . head $ nodeDeclarations tgf
  in buildTree rootId $ edgeDeclarations tgf


buildTree :: NodeId -> [EdgeData] -> Tree NodeId
buildTree rootId edges =
  let childrenOfRoot = mapMaybe (\(fromNodeId, toNodeId, _edgeText) -> if rootId == fromNodeId then Just toNodeId else Nothing) edges
  in Node rootId . fmap (`buildTree` edges) $ childrenOfRoot
