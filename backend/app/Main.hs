#!/usr/bin/env stack
-- stack runghc
  --package turtle
  --package system-filepath
  --package text
  --package bytestring

{-
This script will copy all of those deps.tgf files generated by mvn dependency:tree command below
to "dependency-trees" directory and will rename it to the form "<groupId>:<artifactId>:<packaging>:<version>.tgf"

PREREQUISITE: this script is placed in a folder into which all kiegroup projects have been cloned

USAGE
$ ./droolsjbpm-build-bootstrap/script/mvn-all.sh dependency:tree -DoutputType=tgf -DoutputFile=deps.tgf
$ ./collectDependencyGraphs.hs
-}

{-# LANGUAGE OverloadedStrings #-}
module Main where

import qualified Control.Foldl as Foldl
import qualified Data.Aeson as Json
import qualified Data.ByteString.Lazy as LBS
import qualified Data.List as List
import qualified Data.Text as Txt
import qualified Data.Text.IO as Txt
import Data.Tree (Tree (Node))
import qualified Filesystem.Path.CurrentOS as OSPath
import Prelude hiding (FilePath)
import qualified TGF
import Turtle
import qualified Turtle.Pattern as Pattern
import Util (filepathToString, filepathToText)
import qualified TGF.IO

main :: IO ()
main = do
    prepareOutputFolder
    moduleCoordinatesTree <- analyzeModuleStructure
    saveTree moduleCoordinatesTree
    generateIndexHtml

    Just tgfFile <- fold findDependencyReports Foldl.head
    print tgfFile
    TGF.IO.loadTgfFromFile tgfFile >>= print

    -- putStr "Copying dependency reports to 'dependency-trees' directory "
    -- sh $ findDependencyReports >>= copyToTarget
    -- copiedFilesCount <- fold (Turtle.find (suffix  ".tgf") "dependency-trees") Foldl.length
    -- putStrLn $ show copiedFilesCount <> " files copied"


prepareOutputFolder :: IO ()
prepareOutputFolder = do
    alreadyExists <- testdir depTreesDir
    when alreadyExists $ rmtree depTreesDir
    mkdir depTreesDir


findDependencyReports :: Shell FilePath
findDependencyReports = Turtle.find (Pattern.suffix "/deps.tgf") "."


analyzeModuleStructure :: IO (Tree TGF.Coordinate)
analyzeModuleStructure = do
    putStrLn "Analyzing module structure of repos"
    tgfFiles <- fold findDependencyReports Foldl.list
    let dirsTree = tgfFilesToDirectoryTree tgfFiles
    buildModuleCoordinatesTree dirsTree


-- Build tree of simple dir names from list of deps.tgh files.  At each node of the tree there's a deps.tgf file
tgfFilesToDirectoryTree :: [FilePath] -> Tree FilePath
tgfFilesToDirectoryTree tgfFiles =
    buildModuleDirsTree . fmap splitDirectories $ List.sort tgfFiles


buildModuleDirsTree :: [[FilePath]] -> Tree FilePath
buildModuleDirsTree ps
    | null ps   = Node "DUMMY" []
    | otherwise = Node
        (head $ head ps)
        (map buildModuleDirsTree . List.groupBy (\a b -> head a == head b) . List.sort $ filter ((>1).length {-ignore deps.tgf-}) $ map tail ps)


-- Retrieve list of TGF.Coordinates by parsing it out from deps.tgf file at each node of the tree
buildModuleCoordinatesTree :: Tree FilePath -> IO (Tree TGF.Coordinate)
buildModuleCoordinatesTree (Node curDir subdirs) = do
  let tgfFile = curDir </> OSPath.fromText "deps.tgf"
  tgfFileExists <- testfile tgfFile
  coordHere <- if tgfFileExists
         then do
            contents <- Txt.readFile $ filepathToString tgfFile
            let eitherCoord = TGF.extractRootCoordinate tgfFile contents
            return $ either (const $ TGF.mkCoord "" "" "" "") id eitherCoord
         else do
           Txt.putStrLn $ "WARNING: file " <> filepathToText tgfFile <> " doesn't exist!"
           return $ TGF.mkCoord "" "" "" ""
  subdirCoords <- mapM (\(Node rt children) -> buildModuleCoordinatesTree $  Node (curDir </> rt) children) subdirs
  return $ Node coordHere subdirCoords


{- We want to move the output file of dependency:analyze, like "drools-wb/drools-wb-webapp/deps.tgf"
   to a single folder where each file will have the name of the form "<groupId>:<artifactId>:<packaging>:<version>.tgf"
-}
toTargetFileName :: FilePath -> IO FilePath
toTargetFileName sourceReport = do
    reportContents <- Txt.readFile $ filepathToString sourceReport
    case TGF.extractRootCoordinate sourceReport reportContents of
      Right coord -> return $ depTreesDir </> OSPath.fromText (Txt.pack (show coord)) <.> "tgf"
      Left er     -> die er


copyToTarget :: FilePath -> Shell ()
copyToTarget sourceReport = liftIO $ do
    targetReport <- liftIO $ toTargetFileName sourceReport
    targetAlreadyExists <- testfile targetReport
    if targetAlreadyExists
        then putStrLn $ "WARNING: " <> show targetReport <> " already exists - NOT overwriting!"
        else putStr "." {-progress indicator -} >> cp sourceReport targetReport


saveTree :: Tree TGF.Coordinate -> IO ()
saveTree = LBS.writeFile (filepathToString moduleStructureReport) . Json.encode


depTreesDir :: FilePath
depTreesDir = "dependency-trees"


moduleStructureReport :: FilePath
moduleStructureReport = depTreesDir </> "module-structure.json"


indexHtml :: FilePath
indexHtml = depTreesDir </> "index.html"


{-| Genereates index.html which references elm.js to drive the app. -}
generateIndexHtml :: IO ()
generateIndexHtml = do
    putStrLn "Writing index.html"
    Txt.writeFile (filepathToString indexHtml) $ Txt.unlines
        ["<!DOCTYPE HTML>"
        ,"<html>"
        ,"<head>"
        ,"  <title>kiegroup POMs cleanup</title>"
        ,"  <script src=\"elm.js\"></script>"
        ,"</head>"
        ,"<body>"
        ,"  <script type=\"text/javascript\">Elm.Main.fullscreen()</script>"
        ,"</body>"
        ,"</html>"]
