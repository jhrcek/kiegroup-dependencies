{-
The app collects all data from deps.tgf files generated by mvn dependency:tree command below
into convenient to browse json format suitable to be viewed by a frontend elm app.

USAGE
1) Generate dependency report files for each module using manve
$ cd PATH/TO/kiegroup #folder containing all kiegroup repos
$ ./droolsjbpm-build-bootstrap/script/mvn-all.sh dependency:tree -DoutputType=tgf -DoutputFile=deps.tgf
2)
$ stack exec collect-deps PATH/TO/kiegroup
-}

{-# LANGUAGE OverloadedStrings #-}
module Main where

import           Control.Arrow        ((&&&))
import qualified Control.Foldl        as Foldl
import qualified Data.Aeson           as Json
import qualified Data.ByteString.Lazy as LBS
import           Data.Either          (partitionEithers)
import qualified Data.List            as List
import qualified Data.Text            as Txt
import qualified Data.Text.IO         as Txt
import           Data.Tree            (Tree (Node))
import           Prelude              hiding (FilePath)
import qualified TGF
import qualified TGF.IO
import           Turtle
import qualified Turtle.Pattern       as Pattern
import           Util                 (filepathToString, filepathToText)


main :: IO ()
main = do
    kiegroupDir <- parseArgs
    prepareOutputFolder
    moduleCoordinatesTree <- analyzeModuleStructure kiegroupDir
    saveTree moduleCoordinatesTree
    generateIndexHtml

    tgfFiles <- fold (findDependencyReports kiegroupDir) Foldl.list
    eitherTgfs <- mapM TGF.IO.loadTgfFromFile tgfFiles
    let (parseErrors, parsedTgfs) = partitionEithers eitherTgfs
    print $ length parseErrors
    mapM_ print . List.sort . fmap (length &&& head) . List.group . List.sort $ concatMap (fmap snd . TGF.nodeDeclarations) parsedTgfs

prepareOutputFolder :: IO ()
prepareOutputFolder = do
    alreadyExists <- testdir depTreesDir
    when alreadyExists $ rmtree depTreesDir
    mkdir depTreesDir

findDependencyReports :: FilePath -> Shell FilePath
findDependencyReports = Turtle.find (Pattern.suffix "/deps.tgf")

analyzeModuleStructure :: FilePath -> IO (Tree TGF.Coordinate)
analyzeModuleStructure kiegroupDir = do
    putStrLn "Analyzing module structure of repos"
    tgfFiles <- fold (findDependencyReports kiegroupDir) Foldl.list
    let dirsTree = tgfFilesToDirectoryTree tgfFiles
    buildModuleCoordinatesTree dirsTree

-- Build tree of simple dir names from list of deps.tgh files.  At each node of the tree there's a deps.tgf file
tgfFilesToDirectoryTree :: [FilePath] -> Tree FilePath
tgfFilesToDirectoryTree tgfFiles =
    buildModuleDirsTree . fmap splitDirectories $ List.sort tgfFiles

buildModuleDirsTree :: [[FilePath]] -> Tree FilePath
buildModuleDirsTree ps
    | null ps   = Node "DUMMY" []
    | otherwise = Node
        (head $ head ps)
        (map buildModuleDirsTree . List.groupBy (\a b -> head a == head b) . List.sort $ filter ((>1).length {-ignore deps.tgf-}) $ map tail ps)

-- Retrieve list of TGF.Coordinates by parsing it out from deps.tgf file at each node of the tree
buildModuleCoordinatesTree :: Tree FilePath -> IO (Tree TGF.Coordinate)
buildModuleCoordinatesTree (Node curDir subdirs) = do
    let tgfFile = curDir </> "deps.tgf"
        dummyCoord = TGF.mkCoord "" "" "" ""
    tgfFileExists <- testfile tgfFile
    coordHere <- if tgfFileExists
        then do
            contents <- Txt.readFile $ filepathToString tgfFile
            let eitherCoord = TGF.extractRootCoordinate tgfFile contents
            case eitherCoord of
                Right coord -> return coord
                Left er -> do
                    Txt.putStrLn $ "WARNING: failed to parse TFG data from " <> filepathToText tgfFile <> ". The error was" <> er
                    return dummyCoord
        else do
            Txt.putStrLn $ "WARNING: file " <> filepathToText tgfFile <> " doesn't exist!"
            return dummyCoord
    subdirCoords <- mapM (\(Node rt children) -> buildModuleCoordinatesTree $  Node (curDir </> rt) children) subdirs
    return $ Node coordHere subdirCoords

saveTree :: Tree TGF.Coordinate -> IO ()
saveTree = LBS.writeFile (filepathToString moduleStructureReport) . Json.encode

depTreesDir :: FilePath
depTreesDir = "dependency-trees"

moduleStructureReport :: FilePath
moduleStructureReport = depTreesDir </> "module-structure.json"

indexHtml :: FilePath
indexHtml = depTreesDir </> "index.html"

{-| Genereates index.html which references elm.js to drive the app. -}
generateIndexHtml :: IO ()
generateIndexHtml = do
    putStrLn "Writing index.html"
    Txt.writeFile (filepathToString indexHtml) $ Txt.unlines
        ["<!DOCTYPE HTML>"
        ,"<html>"
        ,"<head>"
        ,"  <title>kiegroup POMs cleanup</title>"
        ,"  <script src=\"elm.js\"></script>"
        ,"</head>"
        ,"<body>"
        ,"  <script type=\"text/javascript\">Elm.Main.fullscreen()</script>"
        ,"</body>"
        ,"</html>"]

parseArgs :: MonadIO io => io FilePath
parseArgs =
    options "Dependency collector" $ argPath "KIEGROUP_DIR" "Directory containing all kiegroup repos"
